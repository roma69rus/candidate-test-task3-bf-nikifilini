"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.codecFromShorthand = void 0;
const t = __importStar(require("io-ts"));
const combinators_1 = require("./combinators");
/* eslint-disable complexity */
/**
 * Gets an io-ts codec from a shorthand input:
 *
 * |shorthand|io-ts type|
 * |-|-|
 * |`String`, `Number`, `Boolean`|`t.string`, `t.number`, `t.boolean`|
 * |Literal raw strings, numbers and booleans e.g. `7` or `'foo'`|`t.literal(7)`, `t.literal('foo')` etc.|
 * |Regexes e.g. `/^foo/`|see [regexp](#regexp)|
 * |`null` and `undefined`|`t.null` and `t.undefined`|
 * |No input (_not_ the same as explicitly passing `undefined`)|`t.unknown`|
 * |Objects e.g. `{ foo: String, bar: { baz: Number } }`|`t.type(...)` e.g. `t.type({foo: t.string, bar: t.type({ baz: t.number }) })`
 * |`Array`|`t.unknownArray`|
 * |`Object`|`t.object`|
 * |One-element arrays e.g. `[String]`|`t.array(...)` e.g. `t.array(t.string)`|
 * |Tuples with explicit length e.g. `[2, [String, Number]]`|`t.tuple` e.g. `t.tuple([t.string, t.number])`|
 * |io-ts codecs|unchanged|
 * |Unions, intersections, partials, tuples with more than 3 elements, and other complex types|not supported, except by passing in an io-ts codec|
 */
exports.codecFromShorthand = (...args) => {
    if (args.length === 0) {
        return t.unknown;
    }
    const v = args[0];
    if (v === String) {
        return t.string;
    }
    if (v === Number) {
        return t.number;
    }
    if (v === Boolean) {
        return t.boolean;
    }
    if (v === Array) {
        return t.UnknownArray;
    }
    if (v === Object) {
        return t.object;
    }
    if (v === null) {
        return t.null;
    }
    if (typeof v === 'undefined') {
        return t.undefined;
    }
    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') {
        return t.literal(v);
    }
    if (v instanceof RegExp) {
        return combinators_1.regexp(v);
    }
    if (Array.isArray(v) && v.length === 0) {
        return t.array(t.unknown);
    }
    if (Array.isArray(v) && v.length === 1) {
        return t.array(exports.codecFromShorthand(v[0]));
    }
    if (Array.isArray(v) && v.length === 2 && typeof v[0] === 'number' && Array.isArray(v[1])) {
        return t.tuple(v[1].map(exports.codecFromShorthand));
    }
    if (Array.isArray(v)) {
        throw new TypeError(`Invalid type. Arrays should be in the form \`[shorthand]\`, and tuples should be in the form \`[3, [shorthand1, shorthand2, shorthand3]]\``);
    }
    if (v instanceof t.Type) {
        return v;
    }
    if (typeof v === 'object' && v) {
        return t.type(Object.entries(v).reduce((acc, [prop, val]) => {
            return Object.assign(Object.assign({}, acc), { [prop]: exports.codecFromShorthand(val) });
        }, {}));
    }
    return t.unknown;
};
//# sourceMappingURL=shorthand.js.map
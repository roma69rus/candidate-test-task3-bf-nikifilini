var e = require("graphql");

var r = require("./b4631212.js");

var t = require("wonka");

function collectTypes(e, r) {
  if (Array.isArray(e)) {
    for (var t = 0; t < e.length; t++) {
      collectTypes(e[t], r);
    }
  } else if ("object" == typeof e && null !== e) {
    for (var n in e) {
      if ("__typename" === n && "string" == typeof e[n]) {
        r[e[n]] = 0;
      } else {
        collectTypes(e[n], r);
      }
    }
  }
  return r;
}

function collectTypesFromResponse(e) {
  return Object.keys(collectTypes(e, {}));
}

var formatNode = function(t) {
  if (t.selectionSet && !t.selectionSet.selections.some((function(r) {
    return r.kind === e.Kind.FIELD && "__typename" === r.name.value && !r.alias;
  }))) {
    return r._extends({}, t, {
      selectionSet: r._extends({}, t.selectionSet, {
        selections: t.selectionSet.selections.concat([ {
          kind: e.Kind.FIELD,
          name: {
            kind: e.Kind.NAME,
            value: "__typename"
          }
        } ])
      })
    });
  }
};

var n = new Map;

function formatDocument(t) {
  var a = r.keyDocument(t);
  var o = n.get(a.__key);
  if (!o) {
    (o = e.visit(a, {
      Field: formatNode,
      InlineFragment: formatNode
    })).__key = a.__key;
    n.set(a.__key, o);
  }
  return o;
}

function maskTypename(e) {
  if (!e || "object" != typeof e) {
    return e;
  }
  return Object.keys(e).reduce((function(r, t) {
    var n = e[t];
    if ("__typename" === t) {
      Object.defineProperty(r, "__typename", {
        enumerable: !1,
        value: n
      });
    } else if (Array.isArray(n)) {
      r[t] = n.map(maskTypename);
    } else if (n && "object" == typeof n && "__typename" in n) {
      r[t] = maskTypename(n);
    } else {
      r[t] = n;
    }
    return r;
  }), {});
}

function withPromise(e) {
  e.toPromise = function() {
    return t.toPromise(t.take(1)(t.filter((function(e) {
      return !e.stale;
    }))(e)));
  };
  return e;
}

function makeOperation(e, r, t) {
  if (!t) {
    t = r.context;
  }
  return {
    key: r.key,
    query: r.query,
    variables: r.variables,
    kind: e,
    context: t
  };
}

function addMetadata(e, t) {
  return makeOperation(e.kind, e, r._extends({}, e.context, {
    meta: r._extends({}, e.context.meta, t)
  }));
}

function noop() {}

function applyDefinitions(t, n, a) {
  for (var o = 0; o < a.length; o++) {
    if (a[o].kind === e.Kind.FRAGMENT_DEFINITION) {
      var i = a[o].name.value;
      var u = r.stringifyDocument(a[o]);
      if (!t.has(i)) {
        t.set(i, u);
        n.push(a[o]);
      } else if ("production" !== process.env.NODE_ENV && t.get(i) !== u) {
        console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + i + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
      }
    } else {
      n.push(a[o]);
    }
  }
}

function shouldSkip$1(e) {
  var r = e.kind;
  return "subscription" !== r && "query" !== r;
}

function shouldSkip(e) {
  var r = e.kind;
  return "mutation" !== r && "query" !== r;
}

function cacheExchange(e) {
  var n = e.forward;
  var a = e.client;
  var o = e.dispatchDebug;
  var i = new Map;
  var u = Object.create(null);
  function mapTypeNames(e) {
    var r = makeOperation(e.kind, e);
    r.query = formatDocument(e.query);
    return r;
  }
  function isOperationCached(e) {
    var r = e.context.requestPolicy;
    return "query" === e.kind && "network-only" !== r && ("cache-only" === r || i.has(e.key));
  }
  return function(e) {
    var c = t.share(e);
    var s = t.map((function(e) {
      var t = i.get(e.key);
      "production" !== process.env.NODE_ENV && o(r._extends({}, {
        operation: e
      }, t ? {
        type: "cacheHit",
        message: "The result was successfully retried from the cache"
      } : {
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache"
      }));
      var n = r._extends({}, t, {
        operation: addMetadata(e, {
          cacheOutcome: t ? "hit" : "miss"
        })
      });
      if ("cache-and-network" === e.context.requestPolicy) {
        n.stale = !0;
        reexecuteOperation(a, e);
      }
      return n;
    }))(t.filter((function(e) {
      return !shouldSkip(e) && isOperationCached(e);
    }))(c));
    var p = t.tap((function(e) {
      var r = e.operation;
      if (!r) {
        return;
      }
      var t = collectTypesFromResponse(e.data).concat(r.context.additionalTypenames || []);
      if ("mutation" === e.operation.kind) {
        var n = new Set;
        "production" !== process.env.NODE_ENV && o({
          type: "cacheInvalidation",
          message: "The following typenames have been invalidated: " + t,
          operation: r,
          data: {
            typenames: t,
            response: e
          },
          source: "cacheExchange"
        });
        for (var c = 0; c < t.length; c++) {
          var s = t[c];
          var p = u[s] || (u[s] = new Set);
          p.forEach((function(e) {
            n.add(e);
          }));
          p.clear();
        }
        n.forEach((function(e) {
          if (i.has(e)) {
            r = i.get(e).operation;
            i.delete(e);
            reexecuteOperation(a, r);
          }
        }));
      } else if ("query" === r.kind && e.data) {
        i.set(r.key, e);
        for (var f = 0; f < t.length; f++) {
          var l = t[f];
          (u[l] || (u[l] = new Set)).add(r.key);
        }
      }
    }))(n(t.filter((function(e) {
      return "query" !== e.kind || "cache-only" !== e.context.requestPolicy;
    }))(t.map((function(e) {
      return addMetadata(e, {
        cacheOutcome: "miss"
      });
    }))(t.merge([ t.map(mapTypeNames)(t.filter((function(e) {
      return !shouldSkip(e) && !isOperationCached(e);
    }))(c)), t.filter((function(e) {
      return shouldSkip(e);
    }))(c) ])))));
    return t.merge([ s, p ]);
  };
}

function reexecuteOperation(e, t) {
  return e.reexecuteOperation(makeOperation(t.kind, t, r._extends({}, t.context, {
    requestPolicy: "network-only"
  })));
}

function dedupExchange(e) {
  var r = e.forward;
  var n = e.dispatchDebug;
  var a = new Set;
  function filterIncomingOperation(e) {
    var r = e.key;
    var t = e.kind;
    if ("teardown" === t) {
      a.delete(r);
      return !0;
    }
    if ("query" !== t && "subscription" !== t) {
      return !0;
    }
    var o = a.has(r);
    a.add(r);
    if (o) {
      "production" !== process.env.NODE_ENV && n({
        type: "dedup",
        message: "An operation has been deduped.",
        operation: e,
        source: "dedupExchange"
      });
    }
    return !o;
  }
  function afterOperationResult(e) {
    a.delete(e.operation.key);
  }
  return function(e) {
    var n = t.filter(filterIncomingOperation)(e);
    return t.tap(afterOperationResult)(r(n));
  };
}

function fetchExchange(e) {
  var n = e.forward;
  var a = e.dispatchDebug;
  return function(e) {
    var o = t.share(e);
    var i = t.mergeMap((function(e) {
      var n = e.key;
      var i = t.filter((function(e) {
        return "teardown" === e.kind && e.key === n;
      }))(o);
      var u = r.makeFetchBody(e);
      var c = r.makeFetchURL(e, u);
      var s = r.makeFetchOptions(e, u);
      "production" !== process.env.NODE_ENV && a({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: e,
        data: {
          url: c,
          fetchOptions: s
        },
        source: "fetchExchange"
      });
      return t.onPush((function(r) {
        var t = !r.data ? r.error : void 0;
        "production" !== process.env.NODE_ENV && a({
          type: t ? "fetchError" : "fetchSuccess",
          message: "A " + (t ? "failed" : "successful") + " fetch response has been returned.",
          operation: e,
          data: {
            url: c,
            fetchOptions: s,
            value: t || r
          },
          source: "fetchExchange"
        });
      }))(t.takeUntil(i)(r.makeFetchSource(e, c, s)));
    }))(t.filter((function(e) {
      return "query" === e.kind || "mutation" === e.kind;
    }))(o));
    var u = n(t.filter((function(e) {
      return "query" !== e.kind && "mutation" !== e.kind;
    }))(o));
    return t.merge([ i, u ]);
  };
}

function fallbackExchange(e) {
  var r = e.dispatchDebug;
  return function(e) {
    return t.filter((function() {
      return !1;
    }))(t.tap((function(e) {
      if ("teardown" !== e.kind && "production" !== process.env.NODE_ENV) {
        var t = 'No exchange has handled operations of kind "' + e.kind + "\". Check whether you've added an exchange responsible for these operations.";
        "production" !== process.env.NODE_ENV && r({
          type: "fallbackCatch",
          message: t,
          operation: e,
          source: "fallbackExchange"
        });
        console.warn(t);
      }
    }))(e));
  };
}

var a = fallbackExchange({
  dispatchDebug: noop
});

function composeExchanges(e) {
  return function(t) {
    var n = t.client;
    var a = t.dispatchDebug;
    return e.reduceRight((function(e, t) {
      return t({
        client: n,
        forward: e,
        dispatchDebug: function dispatchDebug$1(e) {
          "production" !== process.env.NODE_ENV && a(r._extends({}, {
            timestamp: Date.now(),
            source: t.name
          }, e));
        }
      });
    }), t.forward);
  };
}

var o = [ dedupExchange, cacheExchange, fetchExchange ];

var i = function Client(e) {
  if ("production" !== process.env.NODE_ENV && !e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var n = new Map;
  var a = new Map;
  var i = [];
  var u = t.makeSubject();
  var c = u.source;
  var s = u.next;
  var p = !1;
  function dispatchOperation(e) {
    p = !0;
    if (e) {
      s(e);
    }
    while (e = i.shift()) {
      s(e);
    }
    p = !1;
  }
  function makeResultSource(e) {
    var o = t.filter((function(r) {
      return r.operation.kind === e.kind && r.operation.key === e.key;
    }))(k);
    if (l.maskTypename) {
      o = t.map((function(e) {
        return r._extends({}, e, {
          data: maskTypename(e.data)
        });
      }))(o);
    }
    if ("mutation" === e.kind) {
      return t.take(1)(t.onStart((function() {
        return dispatchOperation(e);
      }))(o));
    }
    var u = t.share(t.onEnd((function() {
      n.delete(e.key);
      a.delete(e.key);
      for (var r = i.length - 1; r >= 0; r--) {
        if (i[r].key === e.key) {
          i.splice(r, 1);
        }
      }
      dispatchOperation(makeOperation("teardown", e, e.context));
    }))(t.onStart((function() {
      a.set(e.key, u);
    }))(t.onPush((function(r) {
      n.set(e.key, r);
    }))(t.switchMap((function(n) {
      if ("query" !== e.kind || n.stale) {
        return t.fromValue(n);
      }
      return t.merge([ t.fromValue(n), t.map((function() {
        return r._extends({}, n, {
          stale: !0
        });
      }))(t.take(1)(t.filter((function(r) {
        return "query" === r.kind && r.key === e.key && "cache-only" !== r.context.requestPolicy;
      }))(c))) ]);
    }))(t.takeUntil(t.filter((function(r) {
      return "teardown" === r.kind && r.key === e.key;
    }))(c))(o))))));
    return u;
  }
  var f = this instanceof Client ? this : Object.create(Client.prototype);
  var l = r._extends(f, {
    url: e.url,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    suspense: !!e.suspense,
    requestPolicy: e.requestPolicy || "cache-first",
    preferGetMethod: !!e.preferGetMethod,
    maskTypename: !!e.maskTypename,
    operations$: c,
    reexecuteOperation: function reexecuteOperation(e) {
      if ("mutation" === e.kind || a.has(e.key)) {
        i.push(e);
        if (!p) {
          Promise.resolve().then(dispatchOperation);
        }
      }
    },
    createOperationContext: function createOperationContext(e) {
      if (!e) {
        e = {};
      }
      return r._extends({}, {
        url: l.url,
        fetchOptions: l.fetchOptions,
        fetch: l.fetch,
        preferGetMethod: l.preferGetMethod
      }, e, {
        suspense: e.suspense || !1 !== e.suspense && l.suspense,
        requestPolicy: e.requestPolicy || l.requestPolicy
      });
    },
    createRequestOperation: function createRequestOperation(e, r, t) {
      return makeOperation(e, r, l.createOperationContext(t));
    },
    executeRequestOperation: function executeRequestOperation(e) {
      if ("mutation" === e.kind) {
        return makeResultSource(e);
      }
      var o = a.get(e.key) || makeResultSource(e);
      var i = "cache-and-network" === e.context.requestPolicy || "network-only" === e.context.requestPolicy;
      return t.make((function(a) {
        return t.subscribe(a.next)(t.onEnd(a.complete)(t.onStart((function() {
          var t = n.get(e.key);
          if ("subscription" === e.kind) {
            return dispatchOperation(e);
          } else if (i) {
            dispatchOperation(e);
          }
          if (null != t && t === n.get(e.key)) {
            a.next(i ? r._extends({}, t, {
              stale: !0
            }) : t);
          } else if (!i) {
            dispatchOperation(e);
          }
        }))(o))).unsubscribe;
      }));
    },
    executeQuery: function executeQuery(e, r) {
      var t = l.createRequestOperation("query", e, r);
      return l.executeRequestOperation(t);
    },
    executeSubscription: function executeSubscription(e, r) {
      var t = l.createRequestOperation("subscription", e, r);
      return l.executeRequestOperation(t);
    },
    executeMutation: function executeMutation(e, r) {
      var t = l.createRequestOperation("mutation", e, r);
      return l.executeRequestOperation(t);
    },
    query: function query(e, t, n) {
      if (!n || "boolean" != typeof n.suspense) {
        n = r._extends({}, n, {
          suspense: !1
        });
      }
      return withPromise(l.executeQuery(r.createRequest(e, t), n));
    },
    readQuery: function readQuery(e, r, n) {
      var a = null;
      t.subscribe((function(e) {
        a = e;
      }))(l.query(e, r, n)).unsubscribe();
      return a;
    },
    subscription: function subscription(e, t, n) {
      return l.executeSubscription(r.createRequest(e, t), n);
    },
    mutation: function mutation(e, t, n) {
      return withPromise(l.executeMutation(r.createRequest(e, t), n));
    }
  });
  var d = noop;
  if ("production" !== process.env.NODE_ENV) {
    var h = t.makeSubject();
    var v = h.next;
    var m = h.source;
    l.subscribeToDebugTarget = function(e) {
      return t.subscribe(e)(m);
    };
    d = v;
  }
  var y = composeExchanges(void 0 !== e.exchanges ? e.exchanges : o);
  var k = t.share(y({
    client: l,
    dispatchDebug: d,
    forward: fallbackExchange({
      dispatchDebug: d
    })
  })(c));
  t.publish(k);
  return l;
};

var u = i;

exports.CombinedError = r.CombinedError;

exports.createRequest = r.createRequest;

exports.getOperationName = r.getOperationName;

exports.makeErrorResult = r.makeErrorResult;

exports.makeResult = r.makeResult;

exports.stringifyVariables = r.stringifyVariables;

exports.Client = i;

exports.cacheExchange = cacheExchange;

exports.composeExchanges = composeExchanges;

exports.createClient = u;

exports.debugExchange = function debugExchange(e) {
  var r = e.forward;
  if ("production" === process.env.NODE_ENV) {
    return function(e) {
      return r(e);
    };
  } else {
    return function(e) {
      return t.tap((function(e) {
        return console.log("[Exchange debug]: Completed operation: ", e);
      }))(r(t.tap((function(e) {
        return console.log("[Exchange debug]: Incoming operation: ", e);
      }))(e)));
    };
  }
};

exports.dedupExchange = dedupExchange;

exports.defaultExchanges = o;

exports.errorExchange = function errorExchange(e) {
  var r = e.onError;
  return function(e) {
    var n = e.forward;
    return function(e) {
      return t.tap((function(e) {
        var t = e.error;
        if (t) {
          r(t, e.operation);
        }
      }))(n(e));
    };
  };
};

exports.fallbackExchangeIO = a;

exports.fetchExchange = fetchExchange;

exports.formatDocument = formatDocument;

exports.gql = function gql() {
  var t = arguments;
  var n = new Map;
  var a = [];
  var o = [];
  var i = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "";
  for (var u = 1; u < arguments.length; u++) {
    var c = t[u];
    if (c && c.definitions) {
      o.push.apply(o, c.definitions);
    } else {
      i += c;
    }
    i += t[0][u];
  }
  applyDefinitions(n, a, r.keyDocument(i).definitions);
  applyDefinitions(n, a, o);
  return r.keyDocument({
    kind: e.Kind.DOCUMENT,
    definitions: a
  });
};

exports.makeOperation = makeOperation;

exports.maskTypename = maskTypename;

exports.ssrExchange = function ssrExchange(e) {
  var n = {};
  var a = [];
  function invalidate(e) {
    a.push(e.operation.key);
    if (1 === a.length) {
      Promise.resolve().then((function() {
        var e;
        while (e = a.shift()) {
          n[e] = null;
        }
      }));
    }
  }
  function isCached(e) {
    return !shouldSkip$1(e) && null != n[e.key];
  }
  var ssr = function(a) {
    var o = a.client;
    var i = a.forward;
    return function(a) {
      var u = e && "boolean" == typeof e.isClient ? !!e.isClient : !o.suspense;
      var c = t.share(a);
      var s = i(t.filter((function(e) {
        return !isCached(e);
      }))(c));
      var p = t.map((function(e) {
        return function deserializeResult(e, t) {
          var n = t.error;
          var a = t.data;
          return {
            operation: e,
            data: a ? JSON.parse(a) : void 0,
            extensions: void 0,
            error: n ? new r.CombinedError({
              networkError: n.networkError ? new Error(n.networkError) : void 0,
              graphQLErrors: n.graphQLErrors && n.graphQLErrors.length ? n.graphQLErrors : void 0
            }) : void 0
          };
        }(e, n[e.key]);
      }))(t.filter((function(e) {
        return isCached(e);
      }))(c));
      if (!u) {
        s = t.tap((function(e) {
          var r = e.operation;
          if (!shouldSkip$1(r)) {
            var t = function serializeResult(e) {
              var r = e.data;
              var t = e.error;
              var n = {};
              if (void 0 !== r) {
                n.data = JSON.stringify(r);
              }
              if (t) {
                n.error = {
                  graphQLErrors: t.graphQLErrors.map((function(e) {
                    if (!e.path && !e.extensions) {
                      return e.message;
                    }
                    return {
                      message: e.message,
                      path: e.path,
                      extensions: e.extensions
                    };
                  }))
                };
                if (t.networkError) {
                  n.error.networkError = "" + t.networkError;
                }
              }
              return n;
            }(e);
            n[r.key] = t;
          }
        }))(s);
      } else {
        p = t.tap(invalidate)(p);
      }
      return t.merge([ s, p ]);
    };
  };
  ssr.restoreData = function(e) {
    for (var r in e) {
      if (null !== n[r]) {
        n[r] = e[r];
      }
    }
  };
  ssr.extractData = function() {
    var e = {};
    for (var r in n) {
      if (null != n[r]) {
        e[r] = n[r];
      }
    }
    return e;
  };
  if (e && e.initialState) {
    ssr.restoreData(e.initialState);
  }
  return ssr;
};

exports.subscriptionExchange = function subscriptionExchange(n) {
  var a = n.forwardSubscription;
  var o = n.enableAllOperations;
  return function(n) {
    var i = n.client;
    var u = n.forward;
    function isSubscriptionOperation(e) {
      var r = e.kind;
      return "subscription" === r || !!o && ("query" === r || "mutation" === r);
    }
    return function(n) {
      var o = t.share(n);
      var c = t.mergeMap((function(n) {
        var u = n.key;
        var c = t.filter((function(e) {
          return "teardown" === e.kind && e.key === u;
        }))(o);
        return t.takeUntil(c)(function createSubscriptionSource(n) {
          var o = a({
            key: n.key.toString(36),
            query: e.print(n.query),
            variables: n.variables,
            context: r._extends({}, n.context)
          });
          return t.make((function(e) {
            var t = e.next;
            var a = e.complete;
            var u = !1;
            var c;
            Promise.resolve().then((function() {
              if (u) {
                return;
              }
              c = o.subscribe({
                next: function(e) {
                  return t(r.makeResult(n, e));
                },
                error: function(e) {
                  return t(r.makeErrorResult(n, e));
                },
                complete: function() {
                  if (!u) {
                    u = !0;
                    if ("subscription" === n.kind) {
                      i.reexecuteOperation(makeOperation("teardown", n, n.context));
                    }
                    a();
                  }
                }
              });
            }));
            return function() {
              u = !0;
              if (c) {
                c.unsubscribe();
              }
            };
          }));
        }(n));
      }))(t.filter(isSubscriptionOperation)(o));
      var s = u(t.filter((function(e) {
        return !isSubscriptionOperation(e);
      }))(o));
      return t.merge([ c, s ]);
    };
  };
};
//# sourceMappingURL=urql-core.js.map
